'''
runTimeCommand	-annotation string,
				-category string,
				-categoryArray,
				-command script,
				-commandArray,
				-commandLanguage string,
				-default boolean,
				-defaultCommandArray,
				-delete,
				-exists,
				-hotkeyCtx string,
				-image string,
				-keywords string,
				-label string,
				-longAnnotation string,
				-numberOfCommands,
				-numberOfDefaultCommands,
				-numberOfUserCommands,
				-plugin string,
				-save,
				-showInHotkeyEditor boolean,
				-tags string,
				-userCommandArray,
				name;


-annotation(-ann) string createqueryedit 
		Description of the command.

-category(-cat) string createqueryedit	
		Category for the command.

-categoryArray(-caa) query			
		Return all the run time command categories.

-command(-c) script createqueryedit		
		Command to be executed when runTimeCommand is invoked.

-commandArray(-ca) query				
		Returns an string array containing the names of all the run time commands.

-commandLanguage(-cl) string createqueryedit
		In edit or create mode, this flag allows the caller to choose a scripting language for a command passed to the "-command" flag. If this flag is not specified, then the callback will be assumed to be in the language from which the runTimeCommand command was called. In query mode, the language for this runTimeCommand is returned. The possible values are "mel" or "python".

-default(-d) boolean createquery 		
		Indicate that this run time command is a default command. Default run time commands will not be saved to preferences.

-defaultCommandArray(-dca) query				
		Returns an string array containing the names of all the default run time commands.

-delete(-del) edit 				
		Delete the specified user run time command.

-exists(-ex) create 				
		Returns true|false depending upon whether the specified object exists. Other flags are ignored.

-hotkeyCtx(-hc)	string createqueryedit 	
		hotkey Context for the command.

-image(-i) string createqueryedit 	
		Image filename for the command.

-keywords(-k) string createqueryedit		
		Keywords for the command. Used for searching for commands in Type To Find. When multiple keywords, use ; as a separator. (Example: "keyword1;keyword2")

-label(-l) string createqueryedit		
		Label for the command.

-longAnnotation(-la) string createqueryedit	
		Extensive, multi-line description of the command. This will show up in Type To Finds more info page in addition to the annotation.

-numberOfCommands(-nc) query			
		Return the number of run time commands.

-numberOfDefaultCommands(-ndc) query			
		Return the number of default run time commands.

-numberOfUserCommands(-nuc)	query			
		Return the number of user run time commands.

-plugin(-p)	string createqueryedit			
		Name of the plugin this command requires to be loaded. This flag wraps the script provided into a safety check and automatically loads the plugin referenced on execution if it hasn't been loaded. If the plugin fails to load, the command won't be executed.

-save(-s) edit 							
		Save all the user run time commands.

-showInHotkeyEditor(-she) boolean createqueryedit		
		Indicate that this run time command should be shown in the Hotkey Editor. Default value is true.

-tags(-t) string createqueryedit	
		Tags for the command. Used for grouping commands in Type To Find. When more than one tag, use ; as a separator. (Example: "tag1;tag2")

-userCommandArray(-uca)	query			
		Returns an string array containing the names of all the user run time commands.
'''



//Display:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

//hk_back_face_culling
//Toggle Back-Face Culling
//1
{
string $selection[] = `ls -selection`;//-transforms (all transform objects)
int $query[] = `polyOptions -query -wireBackCulling`;
if ($query[0] != 1){
		polyOptions -global -wireBackCulling;
		setWireframeOnShadedOption 1 (`getPanel -withFocus`);
		inViewMessage -statusMessage "Back-Face Culling is now <hl>OFF</hl>.\n<hl>1</hl>"  -fade -position topCenter;
	}else{
		polyOptions -global -backCulling;
		setWireframeOnShadedOption 0 (`getPanel -withFocus`);
		inViewMessage -statusMessage "Back-Face Culling is now <hl>ON</hl>.\n<hl>1</hl>"  -fade -position topCenter;
	}
}

//hk_smooth_preview
//toggle smooth mesh preview
//2
{
string $selection[] = `ls -selection`;
string $scene[] = `ls -geometry`;

//if no object selected smooth all geometry
if (size($selection)==0)
	{
	for ($object in $scene)
	{
	if (`getAttr ($object+".displaySmoothMesh")` != 2)
		{
		setAttr  ($object+".displaySmoothMesh") 2;//smooth preview on
		displayPref -wireframeOnShadedActive "none";//selection wireframe off
		inViewMessage -statusMessage "S-Div Preview is now <hl>ON</hl>.\n<hl>2</hl>"  -fade -position topCenter;
		}
	else
		{
		setAttr  ($object+".displaySmoothMesh") 0;//smooth preview off
		displayPref -wireframeOnShadedActive "full";//selection wireframe on
		inViewMessage -statusMessage "S-Div Preview is now <hl>OFF</hl>.\n<hl>2</hl>"  -fade -position topCenter;
		}
	if (`getAttr ($object+".smoothLevel")` != 1)
		{
		setAttr  ($object+".smoothLevel") 1;
		}
	}
	}

//smooth selection only
for ($object in $selection)
	{
	if (`getAttr ($object+".displaySmoothMesh")` != 2)
		{
		setAttr  ($object+".displaySmoothMesh") 2;//smooth preview on
		displayPref -wireframeOnShadedActive "none";//selection wireframe off
		inViewMessage -statusMessage "S-Div Preview is now <hl>ON</hl>.\n<hl>2</hl>"  -fade -position topCenter;
		}
	else
		{
		setAttr  ($object+".displaySmoothMesh") 0;//smooth preview off
		displayPref -wireframeOnShadedActive "full";//selection wireframe on
		inViewMessage -statusMessage "S-Div Preview is now <hl>OFF</hl>.\n<hl>2</hl>"  -fade -position topCenter;
		}
	if (`getAttr ($object+".smoothLevel")` != 1)
		{
		setAttr  ($object+".smoothLevel") 1;
		}
	}
}

//hk_isolate_selected
//isolate current selection
//F2
ToggleIsolateSelect;

//hk_grid_and_image_planes
//toggle grid and image plane visibility
//F1
{
string $image_plane[] = `ls -exactType imagePlane`;
for ($object in $image_plane){
	if (`getAttr ($object+".displayMode")` != 2){
		setAttr ($object+".displayMode") 2;
		grid -toggle 1;
		inViewMessage -statusMessage "Grid is now <hl>ON</hl>.\n<hl>F1</hl>"  -fade -position topCenter;
	}else{
		setAttr ($object+".displayMode") 0;
		grid -toggle 0;
		inViewMessage -statusMessage "Grid is now <hl>OFF</hl>.\n<hl>F1</hl>"  -fade -position topCenter;
	}
}
}

//hk_frame_selected
//frame selected by a set amount
//F
{
global int $tk_toggleFrame;

string $selection[] = `ls -selection`;

$mode = `selectMode -query -component`;
$maskVertex = `selectType -query -vertex`;
$maskEdge = `selectType -query -edge`;
$maskFacet = `selectType -query -facet`;

if (size($selection)==0)
	{
	viewFit -allObjects;
	}
	
if ($mode==1 && $maskVertex==1 && size($selection)!=0)
	{
	if (size($selection)>1)
		{
		if ($tk_toggleFrame == !1)
			{
			viewFit -fitFactor .65;
			$tk_toggleFrame = 1;
			print ("frame vertices "+$tk_toggleFrame+"\n");
			}
		else
			{
			viewFit -fitFactor .10;
			//viewSet -previousView;
			$tk_toggleFrame = 0;
			print ("frame vertices "+$tk_toggleFrame+"\n");
			}
		}
	else
		{
		if ($tk_toggleFrame == !1)
			{
			viewFit -fitFactor .15;
			$tk_toggleFrame = 1;
			print ("frame vertex "+$tk_toggleFrame+"\n");
			}
		else
			{
			viewFit -fitFactor .01;
			//viewSet -previousView;
			$tk_toggleFrame = 0;
			print ("frame vertex "+$tk_toggleFrame+"\n");
			}
		}
	}
if ($mode==1 && $maskEdge==1 && size($selection)!=0)
	{
	if ($tk_toggleFrame == !1)
		{
		viewFit -fitFactor .3;
		$tk_toggleFrame = 1;
		print ("frame edge "+$tk_toggleFrame+"\n");
		}
	else
		{
		viewFit -fitFactor .9;
		//viewSet -previousView;
		$tk_toggleFrame = 0;
		print ("frame edge "+$tk_toggleFrame+"\n");
		}
	}
if ($mode==1 && $maskFacet==1)
	{
	if ($tk_toggleFrame == !1)
		{
		viewFit -fitFactor .9;
		$tk_toggleFrame = 1;
		print ("frame facet "+$tk_toggleFrame+"\n");
		}
	else
		{
		viewFit -fitFactor .45;
		//viewSet -previousView;
		$tk_toggleFrame = 0;
		print ("frame facet "+$tk_toggleFrame+"\n");
		}
	}
else if ($mode==0  && size($selection)!=0)
	{
	if ($tk_toggleFrame == !1)
		{
		viewFit -fitFactor .99;
		$tk_toggleFrame = 1;
		print ("frame object "+$tk_toggleFrame+"\n");
		}
	else
		{
		viewFit -fitFactor .65;
		//viewSet -previousView;
		$tk_toggleFrame = 0;
		print ("frame object "+$tk_toggleFrame+"\n");
		}
	}
}

//depricated
//{
//global int $tk_toggleFrame;
//if ($tk_toggleFrame == !1)
//	{
//	viewFit -fitFactor .9;
//	$tk_toggleFrame = 1;
//	}
//else
//	{
//	viewFit -fitFactor .1;
//	//viewSet -previousView;
//	$tk_toggleFrame = 0;
//	}
//}



//Shading:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

//hk_wireframe_on_shaded
//wireframe on shaded
//3
{
string $current_panel = `getPanel -withFocus`;
$mode = `displayPref -query -wireframeOnShadedActive`;

if ($mode=="none")
	{
	displayPref -wireframeOnShadedActive "reduced";
	setWireframeOnShadedOption 1 $current_panel;
	inViewMessage -statusMessage "<hl>Wireframe-on-selection</hl> is now <hl>Full</hl>.\n<hl>3</hl>"  -fade -position topCenter;
	}
if ($mode=="reduced")
	{
		displayPref -wireframeOnShadedActive "full";
	setWireframeOnShadedOption 0 $current_panel;
	inViewMessage -statusMessage "<hl>Wireframe-on-selection</hl> is now <hl>Reduced</hl>.\n<hl>3</hl>"  -fade -position topCenter;
	}
if ($mode=="full")
	{
	displayPref -wireframeOnShadedActive "none";
	setWireframeOnShadedOption 0 $current_panel;
	inViewMessage -statusMessage "<hl>Wireframe-on-selection</hl> is now <hl>OFF</hl>.\n<hl>3</hl>" -fade -position topCenter;
	}
}

// depricated -toggle wireframe on shaded
// string $current_panel = `getPanel -withFocus`;
// int $state = `modelEditor -query -wireframeOnShaded $current_panel`;
// if(`modelEditor -exists $current_panel` && `modelEditor -query -wireframeOnShaded $current_panel` !=1){
// 	setWireframeOnShadedOption 1 $current_panel;
// 	inViewMessage -statusMessage "<hl>Wireframe-on-selection</hl> is now <hl>ON</hl>.\n<hl>3</hl>"  -fade -position topCenter;
// }else{
// 	setWireframeOnShadedOption 0 $current_panel;
// 	inViewMessage -statusMessage "<hl>Wireframe-on-selection</hl> is now <hl>OFF</hl>.\n<hl>3</hl>" -fade -position topCenter;
// }

//hk_xray
//toggle xray mode
//F3

//toggle xRay all
//{
//$currentPanel = `getPanel -withFocus`;
//$state = `modelEditor -q -xray $currentPanel`;
//modelEditor -edit -xray (!$state) $currentPanel;
//}

//xray all except selected
{
string $scene[] = `ls -visible -flatten -dag -noIntermediate -type surfaceShape`;
string $selection[] = `ls -selection -dagObjects -shapes`;
for ($object in $scene)
	{
	if (!stringArrayContains ($object, $selection))
		{
		int $state[] = `displaySurface -query -xRay $object`;
		displaySurface -xRay ( !$state[0] ) $object;
		}
	}
}

//hk_wireframe
//toggle wireframe/shaded/shaded w/texture display
//5
{
string $current_panel = `getPanel -withFocus`;
string $state = `modelEditor -query -displayAppearance $current_panel`;
string $displayTextures = `modelEditor -query -displayTextures $current_panel`;
if(`modelEditor -exists $current_panel`)
  {
	if($state != "wireframe" && $displayTextures == false)
	  {
		modelEditor -edit -displayAppearance smoothShaded -activeOnly false -displayTextures true $current_panel;
		inViewMessage -statusMessage "modelEditor -smoothShaded <hl>true</hl> -displayTextures <hl>true</hl>.\n<hl>5</hl>"  -fade -position topCenter;
		}
	if($state == "wireframe" && $displayTextures == true)
	  {
		modelEditor -edit -displayAppearance smoothShaded -activeOnly false -displayTextures false $current_panel;
		inViewMessage -statusMessage "modelEditor -smoothShaded <hl>true</hl> -displayTextures <hl>false</hl>.\n<hl>5</hl>"  -fade -position topCenter;
		}
	if($state != "wireframe" && $displayTextures == true)
	  {
		modelEditor -edit -displayAppearance wireframe -activeOnly false $current_panel;
		inViewMessage -statusMessage "modelEditor -wireframe <hl>true</hl>.\n<hl>5</hl>"  -fade -position topCenter;
		}
	}
}

//Edit:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

//hk_selection_mode
//toggle between object selection & last component selection
//4
toggleSelMode;

//hk_paste_and_rename
//Hk Paste and rename removing keyword 'paste'
//ctrl+v
//paste and then re-name object removing keyword 'pasted'
cutCopyPaste "paste";
{
string $pasted[] = `ls "pasted__*"`;
string $object;
for ( $object in $pasted )
{
string $elements[];
// The values returned by ls may be full or partial dag
// paths - when renaming we only want the actual
// object name so strip off the leading dag path.
//
tokenize( $object, "|", $elements );
string $stripped = $elements[ `size $elements` - 1 ];
// Remove the 'pasted__' suffix from the name
//
$stripped = `substitute "pasted__" $stripped ""`;
// When renaming a transform its shape will automatically be
// be renamed as well. Use catchQuiet here to ignore errors
// when trying to rename the child shape a second time.
// 
catchQuiet(`evalEcho("rename " + $object + " " + $stripped)`);
}
};
//alternative: edit the cutCopyPaste.mel
//REMOVE the line "-renameAll" so the sub-nodes won't get renamed at all
//REMOVE the -renamingPrefix "paste_" line
//and instead write the line -defaultNamespace

//Hk_multi_component
//Multi Component Selection
//f5
SelectMultiComponentMask;
inViewMessage -statusMessage "<hl>Multi-Component Selection Mode</hl>\n Mask is now <hl>ON</hl>.\n<hl>F4</hl>"  -fade -position topCenter;

//Hk_toggle_component_mask
//Toggle Component Selection Mask
//f4
{
$mode = `selectMode -query -component`;
if ($mode==0)
  {
	changeSelectMode -component;
	}

$maskVertex = `selectType -query -vertex`;
$maskEdge = `selectType -query -edge`;
$maskFacet = `selectType -query -facet`;

if ($maskEdge==0 && $maskFacet==1)
	{
	selectType -vertex true;
	inViewMessage -statusMessage "<hl>Vertex</hl> Mask is now <hl>ON</hl>.\n<hl>F4</hl>"  -fade -position topCenter;
	}
if ($maskVertex==1 && $maskFacet==0)
	{
	selectType -edge true;
	inViewMessage -statusMessage "<hl>Edge</hl> Mask is now <hl>ON</hl>.\n<hl>F4</hl>"  -fade -position topCenter;
	}
if ($maskVertex==0 && $maskEdge==1)
	{
	selectType -facet true;
	inViewMessage -statusMessage "<hl>Facet</hl> Mask is now <hl>ON</hl>.\n<hl>F4</hl>"  -fade -position topCenter;
	}
}

//ui:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

//Hk_hotbox_init
//Display hotbox zones only
//f12
if 'tk' not in locals() or 'tk' not in globals():
	import tk_main;
	from PySide2 import QtWidgets;

	app = QtWidgets.QApplication.instance() #get the qApp instance if it exists.
	if not app:
		app = QtWidgets.QApplication(sys.argv)

	mainWindow = [x for x in app.topLevelWidgets() if x.objectName()=='MayaWindow'][0];
	tk = tk_main.createInstance(mainWindow)

tk.hide(); tk.show()

//#if not tk.isVisible(): tk.show()


//Hk_hotbox_minimal_release
//Close the hotbox
//z (on release)
// tk_tk_init.hbHide()



//Hk_hotbox_full
//Display the full version of the hotbox
//shft + z
{
tk -displayHotbox -polygonsOnlyMenus;
tk;
}



//# -----------------------------------------------
//# Notes
//# -----------------------------------------------

